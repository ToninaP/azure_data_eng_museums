{
	"name": "smk_raw_to_parquet",
	"properties": {
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "smk_artists",
						"type": "DatasetReference"
					},
					"name": "artists"
				},
				{
					"dataset": {
						"referenceName": "smk_artworks",
						"type": "DatasetReference"
					},
					"name": "artworks"
				},
				{
					"dataset": {
						"referenceName": "smk_artworks",
						"type": "DatasetReference"
					},
					"name": "artworksDimensions"
				}
			],
			"sinks": [],
			"transformations": [
				{
					"name": "flattenArtistData"
				},
				{
					"name": "addGenderId"
				},
				{
					"name": "pivotGenderLang"
				},
				{
					"name": "artistsCol"
				},
				{
					"name": "addGenderCol",
					"description": "Creates an explicit mapping for each drifted column"
				},
				{
					"name": "castBirthData"
				},
				{
					"name": "castDeathData"
				},
				{
					"name": "flatten3"
				},
				{
					"name": "flattenDimensions"
				},
				{
					"name": "dimensionsCol"
				},
				{
					"name": "aggregate1"
				},
				{
					"name": "typeCast",
					"description": "Autogenerated by data preview actions"
				},
				{
					"name": "join1"
				},
				{
					"name": "join2"
				},
				{
					"name": "objectID"
				},
				{
					"name": "titleSTR"
				},
				{
					"name": "productionRaw"
				},
				{
					"name": "acquisitionRaw"
				},
				{
					"name": "derivedColumn2"
				},
				{
					"name": "artistIDint"
				},
				{
					"name": "measurementValue1"
				},
				{
					"name": "dimensionsCol2",
					"description": "Creates an explicit mapping for each drifted column"
				}
			],
			"scriptLines": [
				"source(output(",
				"          offset as integer,",
				"          rows as integer,",
				"          found as integer,",
				"          items as (id as string, created as string, modified as string, works as string[], birth_date_end as string[], birth_date_start as string[], death_date_end as string[], death_date_start as string[], gender as string[], name_type as string[])[],",
				"          facets as ({} as string),",
				"          facets_ranges as ({} as string),",
				"          autocomplete as string[]",
				"     ),",
				"     allowSchemaDrift: false,",
				"     validateSchema: false,",
				"     ignoreNoFilesFound: false,",
				"     documentForm: 'documentPerLine') ~> artists",
				"source(output(",
				"          offset as integer,",
				"          rows as integer,",
				"          found as integer,",
				"          items as (id as string, created as string, modified as string, acquisition_date as string, acquisition_date_precision as string, dimensions as (part as string, type as string, unit as string, value as string)[], documentation as (title as string, author as string, notes as string, shelfmark as string, year_of_publication as string)[], object_names as (name as string)[], production as (creator as string, creator_forename as string, creator_surname as string, creator_date_of_birth as string, creator_date_of_death as string, creator_nationality as string, creator_gender as string, creator_lref as string)[], production_date as (start as string, end as string, period as string)[], techniques as string[], object_number as string, object_url as string, frontend_url as string, iiif_manifest as string, enrichment_url as string, similar_images_url as string, production_dates_notes as string[], public_domain as boolean, rights as string, on_display as boolean, image_mime_type as string, image_iiif_id as string, image_iiif_info as string, image_width as integer, image_height as integer, image_size as integer, image_thumbnail as string, image_native as string, image_cropped as boolean, image_orientation as string, image_hq as boolean, has_3d_file as boolean, has_image as boolean, colors as string[], suggested_bg_color as string[], entropy as double, contrast as double, saturation as double, colortemp as double, brightness as double, titles as (title as string, type as string, language as string)[], artist as string[])[],",
				"          facets as ({} as string),",
				"          facets_ranges as ({} as string),",
				"          autocomplete as string[]",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     ignoreNoFilesFound: false,",
				"     documentForm: 'documentPerLine') ~> artworks",
				"source(output(",
				"          offset as integer,",
				"          rows as integer,",
				"          found as integer,",
				"          items as (id as string, created as string, modified as string, acquisition_date as string, acquisition_date_precision as string, dimensions as (part as string, type as string, unit as string, value as string)[], documentation as (title as string, author as string, notes as string, shelfmark as string, year_of_publication as string)[], object_names as (name as string)[], production as (creator as string, creator_forename as string, creator_surname as string, creator_date_of_birth as string, creator_date_of_death as string, creator_nationality as string, creator_gender as string, creator_lref as string)[], production_date as (start as string, end as string, period as string)[], techniques as string[], object_number as string, object_url as string, frontend_url as string, iiif_manifest as string, enrichment_url as string, similar_images_url as string, production_dates_notes as string[], public_domain as boolean, rights as string, on_display as boolean, image_mime_type as string, image_iiif_id as string, image_iiif_info as string, image_width as integer, image_height as integer, image_size as integer, image_thumbnail as string, image_native as string, image_cropped as boolean, image_orientation as string, image_hq as boolean, has_3d_file as boolean, has_image as boolean, colors as string[], suggested_bg_color as string[], entropy as double, contrast as double, saturation as double, colortemp as double, brightness as double, titles as (title as string, type as string, language as string)[], artist as string[])[],",
				"          facets as ({} as string),",
				"          facets_ranges as ({} as string),",
				"          autocomplete as string[]",
				"     ),",
				"     allowSchemaDrift: true,",
				"     validateSchema: false,",
				"     ignoreNoFilesFound: false,",
				"     documentForm: 'documentPerLine') ~> artworksDimensions",
				"artists foldDown(unrollMultiple(items,items.birth_date_end,items.birth_date_start,items.death_date_end,items.death_date_start,items.gender),",
				"     mapColumn(",
				"          artist_id = items.id,",
				"          birth_date_end = items.birth_date_end,",
				"          birth_date_start = items.birth_date_start,",
				"          death_date_end = items.death_date_end,",
				"          death_date_start = items.death_date_start,",
				"          gender = items.gender",
				"     ),",
				"     skipDuplicateMapInputs: false,",
				"     skipDuplicateMapOutputs: false) ~> flattenArtistData",
				"flattenArtistData window(over(artist_id),",
				"     asc(gender, true),",
				"     gender_lang = rowNumber()) ~> addGenderId",
				"addGenderId pivot(groupBy(artist_id,",
				"          birth_date_end,",
				"          birth_date_start,",
				"          death_date_end,",
				"          death_date_start),",
				"     pivotBy(gender_lang),",
				"     {} = first(gender),",
				"     columnNaming: '$N$V',",
				"     lateral: false) ~> pivotGenderLang",
				"castDeathData select(mapColumn(",
				"          artist_id,",
				"          gender = {5},",
				"          artist_birth_raw,",
				"          artist_death_raw",
				"     ),",
				"     skipDuplicateMapInputs: true,",
				"     skipDuplicateMapOutputs: true) ~> artistsCol",
				"pivotGenderLang derive({1} = toString(byName('1')),",
				"          {2} = toString(byName('2')),",
				"          {3} = toString(byName('3')),",
				"          {4} = toString(byName('4')),",
				"          {5} = toString(byName('5')),",
				"          {6} = toString(byName('6')),",
				"          {7} = toString(byName('7')),",
				"          {8} = toString(byName('8')),",
				"          {9} = toString(byName('9'))) ~> addGenderCol",
				"addGenderCol derive(artist_birth_raw = toDate(coalesce(birth_date_start, birth_date_end), 'yyyy-MM-dd')",
				"",
				"",
				") ~> castBirthData",
				"castBirthData derive(artist_death_raw = toDate(coalesce(death_date_start, death_date_end), 'yyyy-MM-dd')) ~> castDeathData",
				"artworks foldDown(unrollMultiple(items,items.production,items.production_date,items.object_names),",
				"     mapColumn(",
				"          id = items.id,",
				"          acquisition_date = items.acquisition_date,",
				"          acquisition_date_precision = items.acquisition_date_precision,",
				"          artist_id = items.production.creator_lref,",
				"          production_date_start = items.production_date.start,",
				"          production_date_end = items.production_date.end,",
				"          techniques = items.techniques,",
				"          inventoryNumber = items.object_number,",
				"          titles = items.titles.title,",
				"          artist_name = items.production.creator",
				"     ),",
				"     skipDuplicateMapInputs: false,",
				"     skipDuplicateMapOutputs: false) ~> flatten3",
				"artworksDimensions foldDown(unrollMultiple(items,items.dimensions),",
				"     mapColumn(",
				"          id = items.id,",
				"          dimension = items.dimensions.type,",
				"          dimension_unit = items.dimensions.unit,",
				"          measurement_value = items.dimensions.value",
				"     ),",
				"     skipDuplicateMapInputs: false,",
				"     skipDuplicateMapOutputs: false) ~> flattenDimensions",
				"flattenDimensions pivot(groupBy(id,",
				"          dimension_unit),",
				"     pivotBy(dimension),",
				"     {} = first(measurement_value),",
				"     columnNaming: '$N$V',",
				"     lateral: false) ~> dimensionsCol",
				"flatten3 aggregate(groupBy(id,",
				"          acquisition_date,",
				"          acquisition_date_precision,",
				"          production_date_start,",
				"          production_date_end,",
				"          inventoryNumber),",
				"     artwork_id = first(id),",
				"          first_artist_id = first(artist_id),",
				"          first_title = first(titles),",
				"          first_medium = first(techniques),",
				"          Artist_name = first(artist_name)) ~> aggregate1",
				"aggregate1 derive(first_title = toString(first_title),",
				"          first_medium = toString(first_medium)) ~> typeCast",
				"typeCast, artistsCol join(first_artist_id == artist_id,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join1",
				"join1, dimensionsCol2 join(artwork_id == dimensionsCol@id,",
				"     joinType:'left',",
				"     matchType:'exact',",
				"     ignoreSpaces: false,",
				"     broadcast: 'auto')~> join2",
				"join2 derive(object_id = toInteger(split(artwork_id, '_')[1])) ~> objectID",
				"objectID derive(title = replace(replace(replace(first_title, '[', ''), ']', ''), '\"', '')) ~> titleSTR",
				"titleSTR derive(production_raw = coalesce(production_date_start,production_date_end)) ~> productionRaw",
				"productionRaw derive(acquisition_raw = coalesce(acquisition_date,acquisition_date_precision)) ~> acquisitionRaw",
				"acquisitionRaw derive(acquisition_method = 'Unknown') ~> derivedColumn2",
				"derivedColumn2 derive(artist_id = toInteger(split(first_artist_id, '_')[1])) ~> artistIDint",
				"artistIDint derive(measurement_value1 = height,",
				"          measurement_value2 = width) ~> measurementValue1",
				"dimensionsCol derive(height = toString(byName('height')),",
				"          width = toString(byName('width'))) ~> dimensionsCol2"
			]
		}
	}
}